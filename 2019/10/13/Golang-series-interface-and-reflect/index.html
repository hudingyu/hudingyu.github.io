<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Go基础系列：深入理解 interface和reflect - Turling的博客 | Turling Blog
        
    </title>

    <link rel="canonical" href="https://turling.me/2019/10/13/Golang-series-interface-and-reflect/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!-- ga & ba script hoook -->
    <script></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script src="https://cdn.bootcss.com/blueimp-md5/2.11.0/js/md5.min.js"></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Turling Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://turling.me/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('star-sky.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Golang" title="Golang">Golang</a>
                        
                    </div>
                    <h1>Go基础系列：深入理解 interface和reflect</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Turling on
                        2019-10-13
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>interface</code>（即接口），是Go语言中一个重要的概念和知识点，而功能强大的<code>reflect</code>正是基于<code>interface</code>。本文即是对Go语言中的<code>interface</code>和<code>reflect</code>基础概念和用法的一次梳理，也算是我阶段学习的总结，以期温故而知新。</p>
<h3 id="interface（接口）"><a href="#interface（接口）" class="headerlink" title="interface（接口）"></a>interface（接口）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在Go语言中，如果自定义类型（比如<code>struct</code>）实现了某个<code>interface</code>中的所有方法，那么就可以说这个类型实现了这个接口。接口可如下定义：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 接口名称<span class="built_in"> interface </span>&#123;</span><br><span class="line">    method1(参数列表) 返回值列表</span><br><span class="line">    method1(参数列表) 返回值列表</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>interface</code>是一组方法的集合，但并不需要实现这些方法，并且<code>interface</code>中<strong>没有变量</strong>。<code>interface</code>中的方法集合可以表示一个对象的特征和能力，当自定义类型需要使用这些方法时，可以根据需要把这些方法实现出来。举个栗子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Eat()</span><br><span class="line">    Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s is eating."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s is running."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat *Cat)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s is eating."</span>, cat.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat *Cat)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s is running."</span>, cat.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> animal1 Animal</span><br><span class="line">	animal1 = &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line">	animal1.Eat()</span><br><span class="line">	animal1.Run()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> animal2 Animal</span><br><span class="line">	animal2 = &amp;Cat&#123;<span class="string">"catty"</span>&#125;</span><br><span class="line">	animal2.Eat()</span><br><span class="line">	animal2.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面即定义了一个Animal接口，以及Dog类型和Cat类型。Dog类型和Cat类型都实现了Animal接口中的方法，所以Dog和Cat都是Animal类型。<br>同时接口<strong>本身不能创建实例</strong>，但从上例可以看出，接口类型的变量可以指向一个实现了该接口的自定义类型的实例。<code>interface</code>类型默认是一个指针(引用类型)，如果没有对<code>interface</code>初始化就使用，那么会输出<code>nil</code>。</p>
<h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>空接口<code>interface{}</code>没有任何方法，所以所有类型都实现了空接口, 即我们可以把任何一个变量赋值给空接口。修改一下上面的main函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> animal <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	dog := &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line">	animal = dog</span><br><span class="line">	fmt.Println(animal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&amp;&#123;doggy&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>一个接口可以继承多个其他接口，如果要实现这个接口，那么必须将所继承的所有接口中的方法都实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eater <span class="keyword">interface</span> &#123;</span><br><span class="line">	Eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Eater</span><br><span class="line">	Runner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义一个Dog的struct，并实现eat方法和run方法，这样就实现了动物的接口</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is eating."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is running."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> animal1 Animal</span><br><span class="line">	animal1 = &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line">	animal1.Eat()</span><br><span class="line">	animal1.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>当我们不确定某个接口变量里存储的是什么类型的变量时，我们可以利用类型断言来判断变量类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal1 Animal</span><br><span class="line">animal1 = &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line">dog := animal1.(*Dog)</span><br></pre></td></tr></table></figure>
<p>在进行类型断言时，如果类型不匹配，就会报<code>panic</code>, 因此需要加上检测机制，如果成功就 ok,否则也不要报 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal1 Animal</span><br><span class="line">animal1 = &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dog, ok := animal1.(*Dog); ok &#123;</span><br><span class="line">	fmt.Println(<span class="string">"convert success"</span>)</span><br><span class="line">    dog.Run()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"convert fail"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外我们也可以使用<code>switch-type</code>语法进行类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eater <span class="keyword">interface</span> &#123;</span><br><span class="line">	Eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Eater</span><br><span class="line">	Runner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is eating."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is running."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat *Cat)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is eating."</span>, cat.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat *Cat)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is running."</span>, cat.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeJudge</span><span class="params">(animals ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> index, animal := <span class="keyword">range</span> animals &#123;</span><br><span class="line">		<span class="keyword">switch</span> animal.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *Dog:</span><br><span class="line">			fmt.Printf(<span class="string">"第%d个参数是Dog类型\n"</span>, index)</span><br><span class="line">		<span class="keyword">case</span> *Cat:</span><br><span class="line">			fmt.Printf(<span class="string">"第%d个参数是Cat类型\n"</span>, index)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"不确定类型"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> animal1 Animal</span><br><span class="line">	animal1 = &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> animal2 Animal</span><br><span class="line">	animal2 = &amp;Cat&#123;<span class="string">"catty"</span>&#125;</span><br><span class="line"></span><br><span class="line">	TypeJudge(animal1, animal2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><code>interface</code>对于Go语言的意义在于其实现了泛型，比如在一个函数中需要能接收不同类型的参数或者返回不同类型的值，而不是一开始就指定参数或者返回值的类型，这样就可以让函数支持所有类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(arg1 <span class="keyword">interface</span>&#123;&#125;, rest ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面向对象语言比如C++、Java都有多态的特性，可以说<code>interface</code>是Go语言中实现多态的一种形式。同一个interface，可以让不同的类（自定义类型）实现，从而可以调用同一个函数名的函数但实现完全不同的功能。</p>
<p>有时我们能够利用<code>interface</code>实现非常巧妙的功能：通常我们定义一个切片（slice）都会指定一个具体的类型，但是我们有时需要切片中的元素可以任何类型的变量，这个时候<code>interface</code>就派上用场了。下面是在go代码中update数据库表中数据时，利用<code>interface</code>实现的骚操作，读者可以体会一下<code>interface</code>带来的便利：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateSQLForUpdatingArticle</span><span class="params">(article model.ArticleStruct)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> columns = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> arguments = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(article.CommentCount) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		columns = <span class="built_in">append</span>(columns, <span class="string">"comment_count = ?"</span>)</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, article.CommentCount)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(article.Source) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		columns = <span class="built_in">append</span>(columns, <span class="string">"source = ?"</span>)</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, article.Source)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(article.Summary) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		columns = <span class="built_in">append</span>(columns, <span class="string">"summary = ?"</span>)</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, article.Summary)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(article.Content) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		columns = <span class="built_in">append</span>(columns, <span class="string">"content = ?"</span>)</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, article.Content)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sql := fmt.Sprintf(<span class="string">"UPDATE article_structs SET %s WHERE sid = %s"</span>, strings.Join(columns, <span class="string">","</span>), article.Sid)</span><br><span class="line">	<span class="keyword">return</span> sql, arguments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateArticle</span><span class="params">(article model.ArticleStruct)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	sql, arguments := generateSQLForUpdatingArticle(article)</span><br><span class="line">	<span class="keyword">if</span> err := db.Exec(sql, arguments...).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"Updating article failed with error:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，空接口<code>interface{}</code> 虽然能保存任意的值，但也带来了一个问题：一个空的接口会隐藏值对应的表示方式和所有的公开的方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值, 对于内部值并没有特别可做的事情；如果我们事先不知道空接口指向的值的具体类型，我们可能就束手无策了。</p>
<p>这个时候我们想要知道一个接口类型的变量具体是什么（什么类型），有什么能力（有哪些方法），就需要一面“镜子”能够反射（<code>reflect</code>）出这个变量的具体内容。在Go语言中也正好有这样的工具——<code>reflect</code>。</p>
<h3 id="reflect-反射"><a href="#reflect-反射" class="headerlink" title="reflect(反射)"></a>reflect(反射)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（<code>self-representation</code>）和监测（<code>examination</code>），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
</blockquote>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>在讲反射之前，我们需要了解一下Golang关于类型设计的一些原则：</p>
<blockquote>
<p>变量包含两部分：type（类型）和value（值）。</p>
</blockquote>
<blockquote>
<p>type 分为 <code>static type</code> 和 <code>concrete type</code>。其中<code>static type</code>是我们在编码阶段用到的数据类型，如int、string、bool等等；而<code>concrete type</code>则是<code>runtime</code>系统看见的类型。</p>
</blockquote>
<blockquote>
<p>接口类型的变量在类型断言时能否成功，取决于<code>concrete type</code> 而不是 <code>static type</code>。</p>
</blockquote>
<p>在Go语言中指定类型的变量的类型都是静态的，即<code>static type</code>，其在创建变量的时候就已经确定；而反射主要是配合<code>interface</code>类型变量来使用的，这些变量的类型都是<code>concrete type</code>。</p>
<p>在Go的实现中，每个<code>interface</code>类型的变量都有一个对应的<code>pair</code>, <code>pair</code>中记录了实际变量的<code>value</code>和<code>type</code>：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">value</span>, type)</span><br></pre></td></tr></table></figure>
<p><code>interface</code>类型变量包含了两个指针，分别指向实际变量的值（value）和类型（对应<code>concrete type</code>）。<code>interface</code>及其<code>pair</code>的存在，是Golang实现反射的前提，而反射也正是用来检测接口类型变量内部存储的值和类型的一种机制。说到这里，自然也就要引出<code>reflect</code>包中的两个数据类<code>Type</code>和<code>Value</code>。</p>
<h4 id="reflect-Type和reflect-Value"><a href="#reflect-Type和reflect-Value" class="headerlink" title="reflect.Type和reflect.Value"></a>reflect.Type和reflect.Value</h4><h5 id="reflect-Type"><a href="#reflect-Type" class="headerlink" title="reflect.Type"></a>reflect.Type</h5><p><code>reflect</code>包中<code>Type</code>接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Kind返回该接口的具体分类</span></span><br><span class="line">    Kind() Kind</span><br><span class="line">    <span class="comment">// Name返回该类型在自身包内的类型名，如果是未命名类型会返回""</span></span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// PkgPath返回类型的包路径，即明确指定包的import路径，如"encoding/base64"</span></span><br><span class="line">    <span class="comment">// 如果类型为内建类型(string, error)或未命名类型(*T, struct&#123;&#125;, []int)，会返回""</span></span><br><span class="line">    PkgPath() <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 返回类型的字符串表示。该字符串可能会使用短包名（如用base64代替"encoding/base64"）</span></span><br><span class="line">    <span class="comment">// 也不保证每个类型的字符串表示不同。如果要比较两个类型是否相等，请直接用Type类型比较。</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 返回要保存一个该类型的值需要多少字节；类似unsafe.Sizeof</span></span><br><span class="line">    Size() <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 返回当从内存中申请一个该类型值时，会对齐的字节数</span></span><br><span class="line">    Align() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回当该类型作为结构体的字段时，会对齐的字节数</span></span><br><span class="line">    FieldAlign() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 如果该类型实现了u代表的接口，会返回真</span></span><br><span class="line">    Implements(u Type) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 如果该类型的值可以直接赋值给u代表的类型，返回真</span></span><br><span class="line">    AssignableTo(u Type) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 如该类型的值可以转换为u代表的类型，返回真</span></span><br><span class="line">    ConvertibleTo(u Type) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 返回该类型的字位数。如果该类型的Kind不是Int、Uint、Float或Complex，会panic</span></span><br><span class="line">    Bits() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回array类型的长度，如非数组类型将panic</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回该类型的元素类型，如果该类型的Kind不是Array、Chan、Map、Ptr或Slice，会panic</span></span><br><span class="line">    Elem() Type</span><br><span class="line">    <span class="comment">// 返回map类型的键的类型。如非映射类型将panic</span></span><br><span class="line">    Key() Type</span><br><span class="line">    <span class="comment">// 返回一个channel类型的方向，如非通道类型将会panic</span></span><br><span class="line">    ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回struct类型的字段数（匿名字段算作一个字段），如非结构体类型将panic</span></span><br><span class="line">    NumField() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回struct类型的第i个字段的类型，如非结构体或者i不在[0, NumField())内将会panic</span></span><br><span class="line">    Field(i <span class="keyword">int</span>) StructField</span><br><span class="line">    <span class="comment">// 返回索引序列指定的嵌套字段的类型，</span></span><br><span class="line">    <span class="comment">// 等价于用索引中每个值链式调用本方法，如非结构体将会panic</span></span><br><span class="line">    FieldByIndex(index []<span class="keyword">int</span>) StructField</span><br><span class="line">    <span class="comment">// 返回该类型名为name的字段（会查找匿名字段及其子字段），</span></span><br><span class="line">    <span class="comment">// 布尔值说明是否找到，如非结构体将panic</span></span><br><span class="line">    FieldByName(name <span class="keyword">string</span>) (StructField, <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 返回该类型第一个字段名满足函数match的字段，布尔值说明是否找到，如非结构体将会panic</span></span><br><span class="line">    FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="params">(StructField, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function">    // 如果函数类型的最后一个输入参数是"..."形式的参数，<span class="title">IsVariadic</span>返回真</span></span><br><span class="line"><span class="function">    // 如果这样，<span class="title">t</span>.<span class="title">In</span><span class="params">(t.NumIn()</span> - 1)返回参数的隐式的实际类型（声明类型的切片）</span></span><br><span class="line"><span class="function">    // 如非函数类型将<span class="title">panic</span></span></span><br><span class="line"><span class="function">    <span class="title">IsVariadic</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    // 返回<span class="title">func</span>类型的参数个数，如果不是函数，将会<span class="title">panic</span></span></span><br><span class="line"><span class="function">    <span class="title">NumIn</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    // 返回<span class="title">func</span>类型的第<span class="title">i</span>个参数的类型，如非函数或者<span class="title">i</span>不在[0, <span class="title">NumIn</span><span class="params">()</span>)内将会<span class="title">panic</span></span></span><br><span class="line"><span class="function">    <span class="title">In</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function">    // 返回<span class="title">func</span>类型的返回值个数，如果不是函数，将会<span class="title">panic</span></span></span><br><span class="line"><span class="function">    <span class="title">NumOut</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    // 返回<span class="title">func</span>类型的第<span class="title">i</span>个返回值的类型，如非函数或者<span class="title">i</span>不在[0, <span class="title">NumOut</span><span class="params">()</span>)内将会<span class="title">panic</span></span></span><br><span class="line"><span class="function">    <span class="title">Out</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function">    // 返回该类型的方法集中方法的数目</span></span><br><span class="line"><span class="function">    // 匿名字段的方法会被计算；主体类型的方法会屏蔽匿名字段的同名方法；</span></span><br><span class="line"><span class="function">    // 匿名字段导致的歧义方法会滤除</span></span><br><span class="line"><span class="function">    <span class="title">NumMethod</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    // 返回该类型方法集中的第<span class="title">i</span>个方法，<span class="title">i</span>不在[0, <span class="title">NumMethod</span><span class="params">()</span>)范围内时，将导致<span class="title">panic</span></span></span><br><span class="line"><span class="function">    // 对非接口类型<span class="title">T</span>或*<span class="title">T</span>，返回值的<span class="title">Type</span>字段和<span class="title">Func</span>字段描述方法的未绑定函数状态</span></span><br><span class="line"><span class="function">    // 对接口类型，返回值的<span class="title">Type</span>字段描述方法的签名，<span class="title">Func</span>字段为<span class="title">nil</span></span></span><br><span class="line"><span class="function">    <span class="title">Method</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">Method</span></span></span><br><span class="line"><span class="function">    // 根据方法名返回该类型方法集中的方法，使用一个布尔值说明是否发现该方法</span></span><br><span class="line"><span class="function">    // 对非接口类型<span class="title">T</span>或*<span class="title">T</span>，返回值的<span class="title">Type</span>字段和<span class="title">Func</span>字段描述方法的未绑定函数状态</span></span><br><span class="line"><span class="function">    // 对接口类型，返回值的<span class="title">Type</span>字段描述方法的签名，<span class="title">Func</span>字段为<span class="title">nil</span></span></span><br><span class="line"><span class="function">    <span class="title">MethodByName</span><span class="params">(<span class="keyword">string</span>)</span> <span class="params">(Method, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function">    // 内含隐藏或非导出方法</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>reflect.TypeOf</code>接受任意<code>interface{}</code>类型，并返回对应的动态类型<code>reflect.Type</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> := reflect.TypeOf(<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="built_in">num</span>.<span class="built_in">String</span>())</span><br><span class="line">fmt.Println(<span class="built_in">num</span>)</span><br></pre></td></tr></table></figure>
<p>看一下<code>TypeOf()</code>的实现代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现<code>TypeOf</code>函数的参数类型是一个<code>interface{}</code>，并且在函数内部将这里的具体值1进行一个隐式转换，转换为一个空接口类型的变量，这个变量包含两部分信息：1这个变量的动态类型（为int）和动态值（为1）；最后<code>TypeOf</code>的返回值是<code>reflect.Type</code>类型（我们称为<strong>反射类型对象</strong>），这样就能够调用上面Type接口的方法获取所需的变量信息。</p>
<ul>
<li>当反射对象的类型是原始数据类型时：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    rString := reflect.TypeOf(s)</span><br><span class="line">    fmt.Println(rString)         <span class="comment">//string</span></span><br><span class="line">    fmt.Println(rString.Name())  <span class="comment">//string,返回表示类型名称的字符串</span></span><br><span class="line">    fmt.Println(rString.Kind())  <span class="comment">//string,返回 reflect.Kind 类型的常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当反射对象的类型是指针类型时：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dogPtr := &amp;Dog&#123;<span class="string">"doggy"</span>&#125;</span><br><span class="line">    rDogPtr := reflect.TypeOf(dogPtr)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(rDogPtr.Name())  <span class="comment">// 为空</span></span><br><span class="line">    fmt.Println(rDogPtr.Kind())  <span class="comment">// ptr</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Elem()可以获取指针指向的实际变量</span></span><br><span class="line">    rDog := rDogPtr.Elem()</span><br><span class="line">    fmt.Println(rDogPtr.Name())  <span class="comment">// Dog</span></span><br><span class="line">    fmt.Println(rDogPtr.Kind())  <span class="comment">// struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现从指针获取反射对象时，不能直接使用<code>Name()</code>和<code>Kind()</code>，这样只能得到该指针的信息。这时可以使用<code>Elem()</code>获取指针指向的实际变量。</p>
<ul>
<li>当反射对象的类型是结构体类型时：</li>
</ul>
<p>如果反射对象的类型是结构体，可以通过 <code>NumField()</code>和 <code>Field()</code> 方法获得结构体成员的详细信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dog := Dog&#123;<span class="string">"doggy"</span>, <span class="number">2</span>&#125;</span><br><span class="line">	rDog := reflect.TypeOf(dog)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%v "</span>, rDog.Name()) <span class="comment">// Dog</span></span><br><span class="line">	fmt.Println(rDog.Kind())       <span class="comment">// struct</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index := <span class="number">0</span>; index &lt; rDog.NumField(); index++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%v "</span>, rDog.Field(index).Name)</span><br><span class="line">		fmt.Println(rDog.Field(index).Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dog <span class="keyword">struct</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<h5 id="reflect-Value"><a href="#reflect-Value" class="headerlink" title="reflect.Value"></a>reflect.Value</h5><p>reflect包中<code>Value</code>类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// typ holds the type of the value represented by a Value.</span></span><br><span class="line">	typ *rtype</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pointer-valued data or, if flagIndir is set, pointer to data.</span></span><br><span class="line">	<span class="comment">// Valid when either flagIndir is set or typ.pointers() is true.</span></span><br><span class="line">	ptr unsafe.Pointer</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// flag holds metadata about the value.</span></span><br><span class="line">	flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Value</code>类型包含一个类型指针、一个值指针以及标志信息。同时<code>Value</code>类型还有很多方法，其中用于获取值方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Int</span><span class="params">()</span> <span class="title">int64</span> // 获取<span class="title">int</span>类型值，如果 <span class="title">v</span> 值不是有符号整型，则 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Uint</span><span class="params">()</span> <span class="title">uint64</span> // 获取<span class="title">unit</span>类型的值，如果 <span class="title">v</span> 值不是无符号整型（包括 <span class="title">uintptr</span>），则 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Float</span><span class="params">()</span> <span class="title">float64</span> // 获取<span class="title">float</span>类型的值，如果 <span class="title">v</span> 值不是浮点型，则 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Complex</span><span class="params">()</span> <span class="title">complex128</span> // 获取复数类型的值，如果 <span class="title">v</span> 值不是复数型，则 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Bool</span><span class="params">()</span> <span class="title">bool</span> // 获取布尔类型的值，如果 <span class="title">v</span> 值不是布尔型，则 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span> // 获取 <span class="title">v</span> 值的长度，<span class="title">v</span> 值必须是字符串、数组、切片、映射、通道。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span>  // 获取 <span class="title">v</span> 值的容量，<span class="title">v</span> 值必须是数值、切片、通道。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Index</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span> // 获取 <span class="title">v</span> 值的第 <span class="title">i</span> 个元素，<span class="title">v</span> 值必须是字符串、数组、切片，<span class="title">i</span> 不能超出范围。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span> // 获取字节类型的值，如果 <span class="title">v</span> 值不是字节切片，则 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Slice</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span> // 获取 <span class="title">v</span> 值的切片，切片长度 = <span class="title">j</span> - <span class="title">i</span>，切片容量 = <span class="title">v</span>.<span class="title">Cap</span><span class="params">()</span> - <span class="title">i</span>。</span></span><br><span class="line"><span class="function">// <span class="title">v</span> 必须是字符串、数值、切片，如果是数组则必须可寻址。<span class="title">i</span> 不能超出范围。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Slice3</span><span class="params">(i, j, k <span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span>  // 获取 <span class="title">v</span> 值的切片，切片长度 = <span class="title">j</span> - <span class="title">i</span>，切片容量 = <span class="title">k</span> - <span class="title">i</span>。</span></span><br><span class="line"><span class="function">// <span class="title">i</span>、<span class="title">j</span>、<span class="title">k</span> 不能超出 <span class="title">v</span> 的容量。<span class="title">i</span> &lt;= <span class="title">j</span> &lt;= <span class="title">k</span>。</span></span><br><span class="line"><span class="function">// <span class="title">v</span> 必须是字符串、数值、切片，如果是数组则必须可寻址。<span class="title">i</span> 不能超出范围。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">MapIndex</span><span class="params">(key Value)</span> <span class="title">reflect</span>.<span class="title">Value</span> // 根据 <span class="title">key</span> 键获取 <span class="title">v</span> 值的内容，<span class="title">v</span> 值必须是映射。</span></span><br><span class="line"><span class="function">// 如果指定的元素不存在，或 <span class="title">v</span> 值是未初始化的映射，则返回零值（<span class="title">reflect</span>.<span class="title">ValueOf</span><span class="params">(<span class="literal">nil</span>)</span>）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">MapKeys</span><span class="params">()</span> []<span class="title">reflect</span>.<span class="title">Value</span> // 获取 <span class="title">v</span> 值的所有键的无序列表，<span class="title">v</span> 值必须是映射。</span></span><br><span class="line"><span class="function">// 如果 <span class="title">v</span> 值是未初始化的映射，则返回空列表。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">OverflowInt</span><span class="params">(x <span class="keyword">int64</span>)</span> <span class="title">bool</span> // 判断 <span class="title">x</span> 是否超出 <span class="title">v</span> 值的取值范围，<span class="title">v</span> 值必须是有符号整型。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">OverflowUint</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">bool</span>  // 判断 <span class="title">x</span> 是否超出 <span class="title">v</span> 值的取值范围，<span class="title">v</span> 值必须是无符号整型。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">OverflowFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">bool</span>  // 判断 <span class="title">x</span> 是否超出 <span class="title">v</span> 值的取值范围，<span class="title">v</span> 值必须是浮点型。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">OverflowComplex</span><span class="params">(x <span class="keyword">complex128</span>)</span> <span class="title">bool</span> // 判断 <span class="title">x</span> 是否超出 <span class="title">v</span> 值的取值范围，<span class="title">v</span> 值必须是复数型。</span></span><br></pre></td></tr></table></figure>
<p>用于设置值方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetUint</span><span class="params">(x <span class="keyword">uint64</span>)</span>  // 设置无符号整型的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> // 设置浮点类型的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetComplex</span><span class="params">(x <span class="keyword">complex128</span>)</span> //设置复数类型的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetBool</span><span class="params">(x <span class="keyword">bool</span>)</span> //设置布尔类型的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetString</span><span class="params">(x <span class="keyword">string</span>)</span> //设置字符串类型的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetLen</span><span class="params">(n <span class="keyword">int</span>)</span>  // 设置切片的长度，<span class="title">n</span> 不能超出范围，不能为负数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetCap</span><span class="params">(n <span class="keyword">int</span>)</span> //设置切片的容量</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetBytes</span><span class="params">(x []<span class="keyword">byte</span>)</span> //设置字节类型的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetMapIndex</span><span class="params">(key, val reflect.Value)</span> //设置<span class="title">map</span>的<span class="title">key</span>和<span class="title">value</span>，前提必须是初始化以后，存在覆盖、不存在添加</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Set</span><span class="params">(x Value)</span> // 将<span class="title">v</span>的持有值修改为<span class="title">x</span>的持有值。如果<span class="title">v</span>.<span class="title">CanSet</span><span class="params">()</span>返回假，会<span class="title">panic</span>。<span class="title">x</span>的持有值必须能直接赋给<span class="title">v</span>持有值的类型。</span></span><br></pre></td></tr></table></figure>
<p>其他方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">结构体相关：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">NumField</span><span class="params">()</span> <span class="title">int</span> // 获取结构体字段（成员）数量</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Field</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span>  //根据索引获取结构体字段</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">FieldByIndex</span><span class="params">(index []<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span> // 根据索引链获取结构体嵌套字段</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">FieldByName</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span> // 根据名称获取结构体的字段，不存在返回<span class="title">reflect</span>.<span class="title">ValueOf</span><span class="params">(<span class="literal">nil</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">FieldByNameFunc</span><span class="params">(match <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">Value</span> // 根据匹配函数 <span class="title">match</span> 获取字段,如果没有匹配的字段，则返回零值（<span class="title">reflect</span>.<span class="title">ValueOf</span><span class="params">(<span class="literal">nil</span>)</span>）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">通道相关：</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Send</span><span class="params">(x reflect.Value)</span>// 发送数据（会阻塞），<span class="title">v</span> 值必须是可写通道。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(x reflect.Value, ok <span class="keyword">bool</span>)</span> // 接收数据（会阻塞），<span class="title">v</span> 值必须是可读通道。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">TrySend</span><span class="params">(x reflect.Value)</span> <span class="title">bool</span> // 尝试发送数据（不会阻塞），<span class="title">v</span> 值必须是可写通道。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">TryRecv</span><span class="params">()</span> <span class="params">(x reflect.Value, ok <span class="keyword">bool</span>)</span> // 尝试接收数据（不会阻塞），<span class="title">v</span> 值必须是可读通道。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Close</span><span class="params">()</span> // 关闭通道</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">函数相关</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span> <span class="params">(r []Value)</span> // 通过参数列表 <span class="title">in</span> 调用 <span class="title">v</span> 值所代表的函数（或方法）。函数的返回值存入 <span class="title">r</span> 中返回。</span></span><br><span class="line"><span class="function">// 要传入多少参数就在 <span class="title">in</span> 中存入多少元素。</span></span><br><span class="line"><span class="function">// <span class="title">Call</span> 即可以调用定参函数（参数数量固定），也可以调用变参函数（参数数量可变）。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">CallSlice</span><span class="params">(in []Value)</span> []<span class="title">Value</span> // 调用变参函数</span></span><br></pre></td></tr></table></figure>
<p>同样地，我们可以通过<code>reflect.ValueOf</code>接受任意interface{}类型，并返回对应的动态类型<code>reflect.Value</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">2</span>)</span><br><span class="line">fmt.Println(v)  <span class="comment">// 2</span></span><br><span class="line">fmt.Println(v.String()) <span class="comment">// &lt;int Value&gt;</span></span><br></pre></td></tr></table></figure>
<p>看一下<code>reflect.ValueOf</code>的实现代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class="line">	<span class="comment">// For now we make the contents always escape to the heap. It</span></span><br><span class="line">	<span class="comment">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class="line">	<span class="comment">// comment below).</span></span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpackEface converts the empty interface i to a Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> don't read e.word until we know whether it is really a pointer or not.</span></span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>escapes() 涉及栈和堆的对象分配以及逃逸分析，有兴趣的可以看 William Kennedy 写的系列文章: <a href="https://studygolang.com/articles/12444" target="_blank" rel="noopener">Go 语言机制之逃逸分析</a></p>
</blockquote>
<p>跟<code>reflect.TypeOf</code>类似，<code>ValueOf</code>函数的参数类型是一个interface{}，在函数内部将入参进行一个隐式转换，转换为一个空接口类型的变量，最终返回一个<code>Value</code>对象，并且<code>reflect.ValueOf</code>返回值也是<strong>反射类型对象</strong>。</p>
<p>可以注意到<code>Value</code>对象中也包含了实际值的类型信息，通过<code>Value</code>的<code>Type()</code> 方法将返回具体类型所对应的<code>reflect.Type</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">2</span>)</span><br><span class="line">t := v.Type()</span><br><span class="line">fmt.Println(t) <span class="comment">// int</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// int</span></span><br></pre></td></tr></table></figure>
<h4 id="通过relfect-Value获取实际变量的信息"><a href="#通过relfect-Value获取实际变量的信息" class="headerlink" title="通过relfect.Value获取实际变量的信息"></a>通过<code>relfect.Value</code>获取实际变量的信息</h4><p>现在我们知道了通过<code>reflect.ValueOf</code>可以将<strong>接口类型变量</strong>转换成<strong>反射类型变量</strong>，当然我们也可以通过<code>reflect.Value.Interface</code>方法逆操作回去，然后通过断言的方式得到实际值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">2</span>)</span><br><span class="line">i := v.Interface()</span><br><span class="line"><span class="keyword">if</span> num, ok := i.(<span class="keyword">int</span>); ok &#123; <span class="comment">// 类型断言</span></span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但通常在实际场景中，我们其实并不知道原始值的类型，这里就需要利用<code>reflect.Type</code>和<code>reflect.Value</code>的方法探索原始值的信息。下面通过一个例子说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is eating."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is running."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span> <span class="title">Sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is sleeping."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span> <span class="title">Jump</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is jumping."</span>, dog.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	doggy := Dog&#123;<span class="string">"doggy"</span>, <span class="number">2</span>&#125;</span><br><span class="line">	checkFieldAndMethod(doggy)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">""</span>)</span><br><span class="line">	tommy := &amp;Dog&#123;<span class="string">"tommy"</span>, <span class="number">2</span>&#125;</span><br><span class="line">	checkFieldAndMethod(tommy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkFieldAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	inputType := reflect.TypeOf(input)</span><br><span class="line">	fmt.Println(<span class="string">"Type of input is :"</span>, inputType.Name())</span><br><span class="line">	inputValue := reflect.ValueOf(input)</span><br><span class="line">	fmt.Println(<span class="string">"Value of input is :"</span>, inputValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果input原始类型时指针，通过Elem()方法或者Indirect()获取指针指向的值</span></span><br><span class="line">	<span class="keyword">if</span> inputValue.Kind() == reflect.Ptr &#123;</span><br><span class="line">		inputValue = inputValue.Elem()</span><br><span class="line">		<span class="comment">// inputValue = reflect.Indirect(inputValue)</span></span><br><span class="line">		fmt.Println(<span class="string">"Value input points to is :"</span>, inputValue)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用NumField()得到结构体中字段的数量，遍历得到字段的值Field(i)和类型Field(i).Type()</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputValue.NumField(); i++ &#123;</span><br><span class="line">		field := inputValue.Type().Field(i)</span><br><span class="line">		value := inputValue.Field(i).Interface()</span><br><span class="line">		fmt.Printf(<span class="string">"%s: %v = %v\n"</span>, field.Name, field.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputType.NumMethod(); i++ &#123;</span><br><span class="line">		m := inputType.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">"%s: %v\n"</span>, m.Name, m.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后输出：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Type of input is : Dog</span><br><span class="line">Value of input is : &#123;doggy <span class="number">2</span>&#125;</span><br><span class="line">Name: <span class="built_in">string</span> = doggy</span><br><span class="line">Age: <span class="built_in">int</span> = <span class="number">2</span></span><br><span class="line">Jump: <span class="function"><span class="keyword">func</span><span class="params">(main.Dog)</span></span></span><br><span class="line"><span class="built_in">Sleep</span>: <span class="function"><span class="keyword">func</span><span class="params">(main.Dog)</span></span></span><br><span class="line"></span><br><span class="line">Type of input is : </span><br><span class="line">Value of input is : &amp;&#123;tommy <span class="number">2</span>&#125;</span><br><span class="line">Value input points <span class="keyword">to</span> is : &#123;tommy <span class="number">2</span>&#125;</span><br><span class="line">Name: <span class="built_in">string</span> = tommy</span><br><span class="line">Age: <span class="built_in">int</span> = <span class="number">2</span></span><br><span class="line">Eat: <span class="function"><span class="keyword">func</span><span class="params">(*main.Dog)</span></span></span><br><span class="line">Jump: <span class="function"><span class="keyword">func</span><span class="params">(*main.Dog)</span></span></span><br><span class="line"><span class="built_in">Run</span>: <span class="function"><span class="keyword">func</span><span class="params">(*main.Dog)</span></span></span><br><span class="line"><span class="built_in">Sleep</span>: <span class="function"><span class="keyword">func</span><span class="params">(*main.Dog)</span></span></span><br></pre></td></tr></table></figure>
<p>利用反射获取原始值得类型和方法的步骤如下：</p>
<ul>
<li>判断原始值是值变量还是指针变量，如果是指针变量，则通过<code>Elem()</code>方法或者<code>Indirect()</code>获取指针指向的值；</li>
<li>使用<code>NumField()</code>得到结构体中字段的数量，遍历得到字段的值<code>Field(i)</code>和类型<code>Field(i).Type()</code>；</li>
<li>使用<code>NumMethod()</code>得到结构体的方法，遍历得到方法的名称和类型。</li>
</ul>
<p>另外，在使用<code>reflect.Value</code>过程有时会对<code>Elem()</code>方法和<code>Indirect()</code>有些迷惑，搞不清这两个方法的区别，这里总结一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Elem returns the value that the interface v contains</span></span><br><span class="line"><span class="comment">// or that the pointer v points to.</span></span><br><span class="line"><span class="comment">// It panics if v's Kind is not Interface or Ptr.</span></span><br><span class="line"><span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Indirect</span> <span class="title">returns</span> <span class="title">the</span> <span class="title">value</span> <span class="title">that</span> <span class="title">v</span> <span class="title">points</span> <span class="title">to</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">v</span> <span class="title">is</span> <span class="title">a</span> <span class="title">nil</span> <span class="title">pointer</span>, <span class="title">Indirect</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">zero</span> <span class="title">Value</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">v</span> <span class="title">is</span> <span class="title">not</span> <span class="title">a</span> <span class="title">pointer</span>, <span class="title">Indirect</span> <span class="title">returns</span> <span class="title">v</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Indirect</span><span class="params">(v Value)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Elem</code>返回v持有的接口保管的值的<code>Value</code>封装，或者v持有的指针指向的值的<code>Value</code>封装。如果v的<code>Kind</code>不是<code>Interface</code>或<code>Ptr</code>会<code>panic</code>；如果v持有的值为<code>nil</code>，会返回<code>Value</code>零值。</li>
<li><code>Indirect</code>返回v持有的指针指向的值的<code>Value</code>封装。如果v持有的值为<code>nil</code>，会返回<code>Value</code>零值。如果v持有的变量不是指针，那么将返回原值v。</li>
</ul>
<p>也就是说，当v持有的变量是指针时，<code>Elem()</code>方法和<code>Indirect()</code>是等价的。</p>
<p>细心的读者可能发现对于值变量和指针变量，通过反射获取到的变量方法有些差异，这个问题就留给读者自己思考吧。</p>
<h4 id="通过relfect-Value修改实际变量的信息"><a href="#通过relfect-Value修改实际变量的信息" class="headerlink" title="通过relfect.Value修改实际变量的信息"></a>通过<code>relfect.Value</code>修改实际变量的信息</h4><p>当通过<code>relfect.Value</code>修改实际变量的信息是常用到以下反射值对象的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span>  </span></span><br><span class="line"><span class="function">//<span class="title">Elem</span><span class="params">()</span>返回<span class="title">v</span>持有的接口保管的值的<span class="title">Value</span>封装，或者<span class="title">v</span>持有的指针指向的值的<span class="title">Value</span>封装，类似于*操作，此时的<span class="title">Value</span>表示的是<span class="title">Value</span>的元素且可以寻址。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Addr</span><span class="params">()</span> <span class="title">Value</span> </span></span><br><span class="line"><span class="function">//<span class="title">Addr</span><span class="params">()</span>返回一个持有指向<span class="title">v</span>变量地址的指针的<span class="title">Value</span>封装，类似于&amp;操作。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">CanAddr</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">//<span class="title">CanAddr</span><span class="params">()</span>返回是否可以获取<span class="title">v</span>持有值的指针。可以获取指针的值被称为可寻址的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">CanSet</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">//<span class="title">CanSet</span><span class="params">()</span>返回<span class="title">v</span>持有的值是否可以被修改</span></span><br></pre></td></tr></table></figure>
<p>然而，值得注意的是并不是所有<code>reflect.Value</code>类型的反射值都可以修改，考虑下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">	rA := reflect.ValueOf(a)</span><br><span class="line">	fmt.Println(rA.CanSet()) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	rAptr := reflect.ValueOf(&amp;a)</span><br><span class="line">	rA2 := rAptr.Elem()</span><br><span class="line">	fmt.Println(rA2.CanSet()) <span class="comment">//true</span></span><br><span class="line">	rA2.SetInt(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(rA2.Int()) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改反射类型变量的值有两个条件：</p>
<ul>
<li>反射类型变量的值是<code>addressable</code>的，即可取地址的；</li>
<li>反射类型变量的值来自导出字段。</li>
</ul>
<p>有一些修改反射类型变量是可寻址的，有一些则不是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    a := reflect.ValueOf(<span class="number">2</span>)</span><br><span class="line">    b := reflect.ValueOf(x)</span><br><span class="line">    c := reflect.ValueOf(&amp;x)</span><br><span class="line">    d := c.Elem()</span><br><span class="line">    fmt.Println(a.CanAddr()) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(b.CanAddr()) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(c.CanAddr()) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(d.CanAddr()) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于非指针变量x，通过<code>reflect.ValueOf(x)</code>返回的 <code>reflect.Value</code>是不可取地址的。但是对于d，它是c的解引用方式生成的，指向另一个变量，因此是可 取地址的。我们可以通过调用<code>reflect.ValueOf(&amp;x).Elem()</code>，获取到x对应的可取地址的反射值。</p>
<p>对于结构体类型变量，如果成员字段没有导出，那么虽然可以被访问，但不能通过反射修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rDog := reflect.ValueOf(&amp;Dog&#123;&#125;).Elem()</span><br><span class="line">	vAge := rDog.FieldByName(<span class="string">"Age"</span>)</span><br><span class="line">	vAge.SetInt(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	vSex := rDog.FieldByName(<span class="string">"sex"</span>)</span><br><span class="line">	vSex.SetString(<span class="string">"male"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行出现报错：SetString使用的值来自于一个未导出的字段。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetString <span class="built_in">using</span> value obtained <span class="built_in">using</span> unexported <span class="built_in">field</span></span><br></pre></td></tr></table></figure>
<p>为了能修改这个值，需要将该字段导出。将Dog类型中的 sex成员首字母大写即可。</p>
<p>修改可取地址的<code>reflect.Value</code>持有的变量值，除了可以通过反射的Set系列方法，还可以通过从反射类型变量获取实际值的指针来修改：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    v := reflect.ValueOf(&amp;x).Elem()</span><br><span class="line">    px := v.Addr().Interface().(*<span class="keyword">int</span>)</span><br><span class="line">    *px = <span class="number">2</span></span><br><span class="line">    fmt.Print(x) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先调用<code>Addr()</code>方法，返回 一个持有指向变量的指针的<code>Value</code>；然后在<code>Value</code>上调用<code>Interface()</code>方法，返回一个 <code>interface{}</code>，里面包含指向变量的指针；最后通过类型断言得到普通指针来修改变量的值。</p>
<h4 id="通过反射调用函数"><a href="#通过反射调用函数" class="headerlink" title="通过反射调用函数"></a>通过反射调用函数</h4><p>如果反射值对象（<code>reflect.Value</code>）持有值的类型为函数时，可以通过 <code>reflect.Value</code> 调用该函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span> []<span class="title">Value</span></span></span><br></pre></td></tr></table></figure>
<p><code>Call</code>方法使用输入的参数in调用v持有的函数。参数in是反射值对象的切片，即<code>[]reflect.Value</code>；调用完成时，函数的返回值通过 <code>[]reflect.Value</code> 返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数add包装为反射值对象</span></span><br><span class="line">    funcValue := reflect.ValueOf(add)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数add的参数, 传入两个整型值</span></span><br><span class="line">    paramList := []reflect.Value&#123;reflect.ValueOf(<span class="number">5</span>), reflect.ValueOf(<span class="number">10</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射调用函数Call()</span></span><br><span class="line">    retList := funcValue.Call(paramList)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个返回值, 取整数值</span></span><br><span class="line">    fmt.Println(retList[<span class="number">0</span>].Int()) <span class="comment">//返回 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要通过反射调用结构体的方法，可以利用<code>MethodByName</code>方法来完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">MethodByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function">//返回<span class="title">v</span>的名为<span class="title">name</span>的方法的已绑定（到<span class="title">v</span>的持有值的）状态的函数形式的<span class="title">Value</span>封装。</span></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    dog.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dog := Dog&#123;&#125;</span><br><span class="line">	rDog := reflect.ValueOf(&amp;dog)</span><br><span class="line">	paramList1 := []reflect.Value&#123;reflect.ValueOf(<span class="string">"doggy"</span>)&#125;</span><br><span class="line">	rDog.MethodByName(<span class="string">"SetName"</span>).Call(paramList1)</span><br><span class="line">	fmt.Println(dog.Name) <span class="comment">//doggy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，反射调用函数的过程需要构造大量的 <code>reflect.Value</code> 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 <code>reflect.Value</code>，用户还需要从中取出调用值。因此反射调用函数的<strong>性能问题尤为突出</strong>，不建议大量使用反射函数调用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了Go语言中<code>interface</code>的定义、用法以及副作用，并由此引入<code>reflect</code>，通过大量示例详细介绍了<code>reflect</code>的概念，通过<code>reflect</code>获取值、修改值的用法，以及调用函数的用法。内容上可以说相当详实具体了，在此过程中也让笔者自己对这部分的知识有了更深刻的认识，也希望有幸能带给读者一点帮助吧。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">【Golang标准库文档】</a></p>
<p><a href="https://www.cnblogs.com/foxy/p/9035271.html" target="_blank" rel="noopener">【Golang的反射reflect深入理解和示例】</a></p>
<p><a href="https://juejin.im/entry/5a961abf6fb9a0634e6cbf02" target="_blank" rel="noopener">【Go addressable 详解】</a></p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2019/11/17/Golang-series-http-server/" data-toggle="tooltip" data-placement="top" title="Go基础系列：深入理解 http server">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2019/07/17/understand-redux-middleware/" data-toggle="tooltip" data-placement="top" title="理解Redux中间件，这一篇就够了">Next Post &rarr;</a>
                        </li>
                    
                </ul>
                <div id="gitalk-container"></div>
                

                

            </div>

            
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/hudingyu">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Turling Blog 2019 
                    <!-- <br> -->
                    <!-- Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> |  -->
                    <!-- <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://turling.me/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<script type="text/javascript">
    const gitalk = new Gitalk({
        clientID: 'd526317e8c13bd9e1344',
        clientSecret: '3f2e043a8a04f4babf9e5d0804fd8e14f1b8d75d',
        repo: 'blog-comments',
        owner: 'hudingyu',
        admin: ['hudingyu'],
        id: md5(location.pathname),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
  </script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '140353961df3b8b3911818d8a175b712';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<!-- <img src="https://turling.me/img/icon_wechat.png" width="0" height="0" /> -->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
